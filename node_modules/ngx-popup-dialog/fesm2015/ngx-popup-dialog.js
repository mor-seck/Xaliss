import { Overlay } from '@angular/cdk/overlay';
import { Component, ComponentFactoryResolver, HostListener, Inject, ReflectiveInjector, ViewChild, ViewContainerRef, ViewEncapsulation, InjectionToken, Injectable, NgModule } from '@angular/core';
import { MAT_DIALOG_DATA, MatDialogConfig, MatDialogRef, MatDialog, MatDialogModule } from '@angular/material/dialog';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const POPUP_DIALOG_CLOSE = new InjectionToken('POPUP_DIALOG_CLOSE');
class PopupDialog {
    /**
     * @param {?} componentFactoryResolver
     * @param {?} dialogRef
     * @param {?} data
     */
    constructor(componentFactoryResolver, dialogRef, data) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.dialogRef = dialogRef;
        this.visible = false;
        this.isOpened = false;
        this.scaleBottomToTop = false;
        this.scrollBoundedFunction = this.onScroll.bind(this);
        // set events handled to true to ignore event when popup opened for the first time.
        this.mouseDownHandled = true;
        this.mouseUpHandled = true;
        this.clickHandled = true;
        this.config = data.config;
        this.data = data.data;
        this.direction = data.config.direction || (/** @type {?} */ (getComputedStyle(this.config.triggeringElement).direction));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onScroll(event) {
        this.positionDialogWhereTriggeringElement();
        this.positionDialogUpIfBottomOutsideViewport();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseDown(event) {
        this.handleMouseEvent(event);
        this.mouseDownHandled = true;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseUp(event) {
        if (this.mouseDownHandled || this.clickHandled) {
            this.mouseDownHandled = false;
            this.clickHandled = false;
            return;
        }
        this.handleMouseEvent(event);
        this.mouseUpHandled = true;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        if (this.mouseDownHandled || this.mouseUpHandled) {
            this.mouseDownHandled = false;
            this.mouseUpHandled = false;
            return;
        }
        this.handleMouseEvent(event);
        this.clickHandled = true;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleMouseEvent(event) {
        if (!this.isOpened)
            return;
        // Clicking on element will trigger this callback function multiple times (for mouse down, up and click)
        // Therefor, we stop execution if we get the same event target.
        // We reset the lastClickedElement after 100 ms
        if (this.lastClickedElement == event.target)
            return;
        this.lastClickedElement = event.target;
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.lastClickedElement = null;
        }), 200);
        /** @type {?} */
        var container = this.dialogContainerRef.nativeElement;
        if (container === event.target || this.childOf(event.target, container)) {
            return;
        }
        if (this.config.suppressCloseOnClickSelectors) {
            for (let i = 0; i < this.config.suppressCloseOnClickSelectors.length; i++) {
                /** @type {?} */
                const selector = this.config.suppressCloseOnClickSelectors[i];
                /** @type {?} */
                const elements = document.querySelectorAll(selector);
                for (let i = 0; i < elements.length; i++) {
                    /** @type {?} */
                    const elem = elements[i];
                    if (elem === event.target || this.childOf(event.target, elem)) {
                        return;
                    }
                }
            }
        }
        this.closeDialog();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.registerOrUnregisterAncestrosScrollEvent();
        this.loadComponent();
        this.dialogRef.beforeClose().subscribe((/**
         * @param {?} x
         * @return {?}
         */
        x => {
            this.visible = false;
            this.isOpened = false;
        }));
        this.dialogRef.afterOpen().subscribe((/**
         * @param {?} x
         * @return {?}
         */
        x => {
            this.isOpened = true;
        }));
        this.positionDialogWhereTriggeringElement();
        this.positionDialogUpIfBottomOutsideViewport();
        this.visible = true;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.registerOrUnregisterAncestrosScrollEvent(false);
    }
    /**
     * @return {?}
     */
    loadComponent() {
        /** @type {?} */
        let componentFactory = this.componentFactoryResolver.resolveComponentFactory((/** @type {?} */ (this.config.component)));
        this.popupContentViewContainer.clear();
        /** @type {?} */
        const injector = ReflectiveInjector.resolveAndCreate([
            {
                provide: MAT_DIALOG_DATA,
                useValue: this.data || {}
            },
            {
                provide: POPUP_DIALOG_CLOSE,
                useValue: this.closeDialog.bind(this)
            }
        ]);
        /** @type {?} */
        let componentRef = this.popupContentViewContainer.createComponent(componentFactory, 0, injector);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    containerTransitionEnd(event) {
        if (event.target == this.dialogContainerRef.nativeElement && !this.visible) {
            this.dialogRef.close(this.dialogResult);
        }
    }
    /**
     * @param {?=} dialogResult
     * @return {?}
     */
    closeDialog(dialogResult) {
        this.dialogResult = dialogResult;
        this.visible = false;
        this.isOpened = false;
    }
    /**
     * @private
     * @param {?=} register
     * @return {?}
     */
    registerOrUnregisterAncestrosScrollEvent(register = true) {
        /** @type {?} */
        let elem = ((/** @type {?} */ (this.config.triggeringElement))).parentNode;
        while (elem !== null) {
            register ?
                elem.addEventListener("scroll", this.scrollBoundedFunction) :
                elem.removeEventListener("scroll", this.scrollBoundedFunction);
            elem = elem.parentNode;
        }
    }
    /**
     * @private
     * @return {?}
     */
    positionDialogWhereTriggeringElement() {
        /** @type {?} */
        const matDialogConfig = new MatDialogConfig();
        /** @type {?} */
        const rect = this.config.triggeringElement.getBoundingClientRect();
        /** @type {?} */
        let top = this.config.coverTriggeringElement ?
            rect.bottom - this.config.triggeringElement.offsetHeight - 1 :
            rect.bottom;
        matDialogConfig.position = { top: `${top}px` };
        if (this.direction == 'rtl') {
            /** @type {?} */
            let right = window.innerWidth - rect.left - this.config.triggeringElement.offsetWidth;
            matDialogConfig.position.right = `${right}px`;
        }
        else {
            matDialogConfig.position.left = `${rect.left}px`;
        }
        this.dialogRef.updatePosition(matDialogConfig.position);
    }
    /**
     * @private
     * @return {?}
     */
    positionDialogUpIfBottomOutsideViewport() {
        if (!this.config.scaleToTopOnBottomOverflow)
            return;
        /** @type {?} */
        let dialogContainerElem = (/** @type {?} */ (this.dialogContainerRef.nativeElement));
        /** @type {?} */
        let result = this.isOutOfViewport();
        if (result.bottom && !result.topIfScaleToTop) {
            this.scaleBottomToTop = true;
            /** @type {?} */
            const matDialogConfig = new MatDialogConfig();
            /** @type {?} */
            const rect = dialogContainerElem.getBoundingClientRect();
            /** @type {?} */
            let triggeringElementHeight = this.config.triggeringElement.offsetHeight;
            /** @type {?} */
            let top = this.config.coverTriggeringElement ?
                rect.top - dialogContainerElem.offsetHeight + triggeringElementHeight + 1 :
                rect.top - dialogContainerElem.offsetHeight - triggeringElementHeight;
            matDialogConfig.position = { top: `${top}px` };
            if (this.direction == 'rtl') {
                /** @type {?} */
                let right = window.innerWidth - rect.left - this.config.triggeringElement.offsetWidth;
                matDialogConfig.position.right = `${right}px`;
            }
            else {
                matDialogConfig.position.left = `${rect.left}px`;
            }
            this.dialogRef.updatePosition(matDialogConfig.position);
        }
        else {
            this.scaleBottomToTop = false;
        }
    }
    /**
     * @private
     * @return {?}
     */
    isOutOfViewport() {
        /** @type {?} */
        let container = this.dialogContainerRef.nativeElement;
        /** @type {?} */
        let triggeringElement = this.config.triggeringElement;
        // Get element's bounding
        /** @type {?} */
        var bounding = container.getBoundingClientRect();
        // reduce height from top position if scale to top
        /** @type {?} */
        let top = bounding.top;
        if (this.scaleBottomToTop) {
            top = this.config.coverTriggeringElement ?
                bounding.top - container.offsetHeight + triggeringElement.offsetHeight :
                bounding.top - container.offsetHeight - triggeringElement.offsetHeight;
        }
        /** @type {?} */
        let topIfScaleToTop = top;
        if (!this.scaleBottomToTop) {
            topIfScaleToTop = top - (this.config.coverTriggeringElement ? container.offsetHeight - triggeringElement.offsetHeight : container.offsetHeight + triggeringElement.offsetHeight);
        }
        /** @type {?} */
        var out = {};
        out.top = top < 0;
        out.topIfScaleToTop = topIfScaleToTop < 0;
        out.left = bounding.left < 0;
        out.bottom = (bounding.top + container.offsetHeight) > (window.innerHeight || document.documentElement.offsetHeight);
        if (this.scaleBottomToTop && !out.bottom) {
            if (!out.top)
                out.bottom = true;
        }
        out.right = (bounding.left + container.offsetWidth) > (window.innerWidth || document.documentElement.offsetWidth);
        out.any = out.top || out.left || out.bottom || out.right;
        out.all = out.top && out.left && out.bottom && out.right;
        return out;
    }
    ;
    /**
     * @private
     * @param {?} node
     * @param {?} ancestor
     * @return {?}
     */
    childOf(node, ancestor) {
        /** @type {?} */
        var child = node;
        while (child !== null) {
            if (child === ancestor)
                return true;
            child = child.parentNode;
        }
        return false;
    }
}
PopupDialog.decorators = [
    { type: Component, args: [{
                selector: 'popup-dialog',
                template: "<div #dialogContainer [attr.dir]=\"direction == 'rtl' ? 'rtl' : ''\" (transitionend)=\"containerTransitionEnd($event)\"\n class=\"ngx-popup-dialog-container\" [ngClass]=\"{'visible': visible, 'scale-to-top': scaleBottomToTop, 'rtl': direction == 'rtl'}\"\n [style.max-width]=\"config.maxWidth\" [style.max-height]=\"config.maxHeight\">\n  <ng-template #popupContent></ng-template>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".ngx-popup-dialog-overlay{display:block}.ngx-popup-dialog-overlay .mat-dialog-container{display:inline;padding:0}.ngx-popup-dialog-container{box-shadow:0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12),0 2px 4px -1px rgba(0,0,0,.2);background:#fff;border-radius:2px;overflow:auto;transition:transform 150ms cubic-bezier(.4,0,1,1);transition:transform 150ms cubic-bezier(.4,0,1,1),-webkit-transform 150ms cubic-bezier(.4,0,1,1);-webkit-transform-origin:top left;transform-origin:top left;-webkit-transform:scale3d(0,0,1);transform:scale3d(0,0,1)}.ngx-popup-dialog-container.rtl{-webkit-transform-origin:top right;transform-origin:top right;direction:rtl}.ngx-popup-dialog-container.visible{transition:transform 150ms cubic-bezier(0,0,.2,1);transition:transform 150ms cubic-bezier(0,0,.2,1),-webkit-transform 150ms cubic-bezier(0,0,.2,1);-webkit-transform:scale3d(1,1,1);transform:scale3d(1,1,1)}.ngx-popup-dialog-container.scale-to-top{-webkit-transform-origin:left bottom 0;transform-origin:left bottom 0}.ngx-popup-dialog-container.rtl.scale-to-top{-webkit-transform-origin:right bottom 0;transform-origin:right bottom 0}.ngx-popup-dialog-container::-webkit-scrollbar{width:6px;background-color:#f5f5f5}.ngx-popup-dialog-container::-webkit-scrollbar-thumb{border-radius:10px;-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3);background-color:#d9d9d9}"]
            }] }
];
/** @nocollapse */
PopupDialog.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: MatDialogRef },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];
PopupDialog.propDecorators = {
    popupContentViewContainer: [{ type: ViewChild, args: ['popupContent', { read: ViewContainerRef },] }],
    dialogContainerRef: [{ type: ViewChild, args: ['dialogContainer',] }],
    onMouseDown: [{ type: HostListener, args: ['document:mousedown', ['$event'],] }],
    onMouseUp: [{ type: HostListener, args: ['document:mouseup', ['$event'],] }],
    onClick: [{ type: HostListener, args: ['document:click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PopupDialogService {
    /**
     * @param {?} _overlay
     * @param {?} _dialogService
     */
    constructor(_overlay, _dialogService) {
        this._overlay = _overlay;
        this._dialogService = _dialogService;
    }
    /**
     * @template T
     * @param {?} componentOrTemplateRef
     * @param {?} triggeringElement
     * @param {?=} config
     * @return {?}
     */
    open(componentOrTemplateRef, triggeringElement, config) {
        if (!config)
            config = {};
        /** @type {?} */
        let data = config.data;
        delete config.data;
        /** @type {?} */
        const popupDialogData = {
            config: Object.assign({}, config, { component: componentOrTemplateRef, triggeringElement: triggeringElement, maxWidth: (typeof config.maxWidth === "number") ? config.maxWidth + 'px' : config.maxWidth, maxHeight: (typeof config.maxHeight === "number") ? config.maxHeight + 'px' : config.maxHeight, scaleToTopOnBottomOverflow: config.scaleToTopOnBottomOverflow == null ? true : config.scaleToTopOnBottomOverflow, suppressCloseOnClickSelectors: typeof config.suppressCloseOnClickSelectors === "string" ? [config.suppressCloseOnClickSelectors] : config.suppressCloseOnClickSelectors }),
            data: data
        };
        /** @type {?} */
        const popupDialogConfig = {
            backdropClass: 'cdk-overlay-transparent-backdrop',
            hasBackdrop: false,
            scrollStrategy: this._overlay.scrollStrategies.noop(),
            panelClass: 'ngx-popup-dialog-overlay',
            restoreFocus: false,
            data: popupDialogData
        };
        /** @type {?} */
        let dialogRef = this._dialogService.open(PopupDialog, popupDialogConfig);
        return dialogRef;
    }
}
PopupDialogService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
PopupDialogService.ctorParameters = () => [
    { type: Overlay },
    { type: MatDialog }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPopupDialogModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: NgxPopupDialogModule,
            providers: [PopupDialogService]
        };
    }
}
NgxPopupDialogModule.decorators = [
    { type: NgModule, args: [{
                declarations: [PopupDialog],
                imports: [
                    CommonModule,
                    FormsModule,
                    MatDialogModule
                ],
                entryComponents: [PopupDialog],
                exports: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgxPopupDialogModule, PopupDialogService, POPUP_DIALOG_CLOSE, PopupDialog as ɵa };

//# sourceMappingURL=ngx-popup-dialog.js.map